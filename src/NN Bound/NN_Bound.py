from ortools.linear_solver import pywraplpfrom os import system, nameimport networkx as nximport matplotlib.pyplot as pltfrom networkx.drawing.nx_agraph import graphviz_layoutimport datetimedef clear():	if name == 'nt':		_ = system('cls')	else:		_ = system('clear')G = nx.DiGraph()positive_infnity = float('inf')negative_infnity = float('-inf')# Create a new modelsolver = pywraplp.Solver.CreateSolver('SCIP')#Getting input from the user:inp=int(input("Enter the number of layer(including input and output): "))no = []for i in range(inp):    no.append(int(input(f"Enter the number of nodes in layer {i}: "))) z = []for i in range(inp):    z.append([])    for j in range(no[i]):        z[i].append(0)b = []for i in range(inp):    b.append([])    for j in range(no[i]):        b[i].append(0)t = []for i in range(inp):    t.append([])    for j in range(no[i]):        t[i].append(0)w = []for i in range(inp):    w.append([])    for j in range(no[i-1]):        w[i].append([])        for k in range(no[i]):            w[i][j].append(0)        for i in range(inp):    for j in range(no[i]):        z[i][j] = solver.NumVar(negative_infnity,positive_infnity , f"x{i}{j}")        G.add_node(f"z[{i}][{j}]")        if i == 0:            ub=int(input(f"\tEnter the upper bound for z{i}{j}: "))            lb=int(input(f"\tEnter the lower bound for z{i}{j}: "))            solver.Add(z[i][j] >= lb)            solver.Add(z[i][j] <= ub)        if i!= inp-1 and i!=0:        	            t[i][j] = solver.IntVar(0, 1, f"t{i}{j}")            solver.Add(t[i][j] >= 0)            solver.Add(t[i][j] <= 1)            b[i][j] = int(input(f"Enter the bias for z{i}{j}: "))summ = []for i in range(inp):    summ.append([])    for j in range(no[i]):        summ[i].append(0)for i in range(1,inp):    for j in range(no[i-1]):            for k in range(no[i]):                w[i][j][k] = int(input(f"Enter the weight from z{i-1}{j} to z{i}{k}: "))                G.add_edge(f"z[{i-1}][{j}]",f"z[{i}][{k}]", weight = w[i][j][k]) for i in range(inp):	for j in range(no[i]):		for k in range(no[i-1]):			if i!=0:				summ[i][j] = summ[i][j] + w[i][k][j]*z[i-1][k] + b[i][j]M = int(input("Enter the value of Big M: "))Y = 0for j in range(inp-1):      for k in range(no[inp-1]):                      Y = Y + z[inp-2][j]*w[inp-1][j][k]#Set constraintsfor i in range(1,inp-1):    for j in range(no[i]):            solver.Add(z[i][j] >= summ[i][j])            solver.Add(z[i][j] <= summ[i][j] + M*t[i][j])            solver.Add(z[i][j] <= M*(1-t[i][j]))t1 = datetime.datetime.now()#Optimize model Maximizesolver.Maximize(Y)status_1 = solver.Solve()if status_1 == pywraplp.Solver.OPTIMAL:    u = solver.Objective().Value()#Set Objective Minimizesolver.Minimize(Y)status_2 = solver.Solve()if status_2== pywraplp.Solver.OPTIMAL:    l = solver.Objective().Value()#clear()#pos = graphviz_layout(G, prog='dot', args="-Grankdir=LR")#nx.draw(G,with_labels=True,pos=pos, font_weight='bold')#nx.draw_networkx_edge_labels(G,pos=pos, font_weight='bold')t2 = datetime.datetime.now()print(f"The neural network output range is : [{l},{u}]")print("Time taken by NN_Bound using SCIP (hr:min:sec): ", t2-t1)#plt.savefig("Graph.png", format="PNG")